From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Keeley Hammond <khammond@slack-corp.com>
Date: Tue, 14 Jan 2025 15:50:29 -0800
Subject: feat: allow desktop capturer to return either screen, window or both
 and make MacOS SCContentSharingPicker work in Electron

This patch is a work in progress that contains assorted changes to make the MacOS SCContentSharingPicker upstream implementation work within Electron. If this comment is still in this patch during PR review, it is not ready for prime time

This patch can be removed after our desktopCapturer is refactored.

diff --git a/chrome/browser/media/webrtc/capture_policy_utils.cc b/chrome/browser/media/webrtc/capture_policy_utils.cc
index 85320190d406bdd37175ddb5d207d124b278b648..677dfdbc761dcc942b865ed073b16ea7c8a269da 100644
--- a/chrome/browser/media/webrtc/capture_policy_utils.cc
+++ b/chrome/browser/media/webrtc/capture_policy_utils.cc
@@ -362,6 +362,7 @@ void FilterMediaList(std::vector<DesktopMediaList::Type>& media_types,
       media_types, [capture_level](const DesktopMediaList::Type& type) {
         switch (type) {
           case DesktopMediaList::Type::kNone:
+            // return capture_level < AllowedScreenCaptureLevel::kDesktop;
             NOTREACHED();
           // SameOrigin is more restrictive than just Tabs, so as long as
           // at least SameOrigin is allowed, these entries should stay.
diff --git a/chrome/browser/media/webrtc/desktop_media_list_base.cc b/chrome/browser/media/webrtc/desktop_media_list_base.cc
index 08400be4d1bae18502d19beed6b2d9057e55dd4f..d2ec9baf3219f4b38db4771a1ca1b3b5fd86dba0 100644
--- a/chrome/browser/media/webrtc/desktop_media_list_base.cc
+++ b/chrome/browser/media/webrtc/desktop_media_list_base.cc
@@ -15,6 +15,7 @@
 #include "base/functional/bind.h"
 #include "base/hash/hash.h"
 #include "chrome/browser/media/webrtc/desktop_media_list.h"
+#include "chrome/browser/media/webrtc/thumbnail_capturer_mac.h"
 #include "content/public/browser/browser_task_traits.h"
 #include "content/public/browser/browser_thread.h"
 #include "third_party/skia/include/core/SkBitmap.h"
@@ -77,7 +78,13 @@ void DesktopMediaListBase::StartUpdating(DesktopMediaListObserver* observer) {
 void DesktopMediaListBase::Update(UpdateCallback callback, bool refresh_thumbnails) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK(sources_.empty());
-  DCHECK(!refresh_callback_);
+  #if BUILDFLAG(IS_MAC)
+   if (!ShouldUseSCContentSharingPicker()) {
+    DCHECK(!refresh_callback_);
+   };
+  #else
+    DCHECK(!refresh_callback_);
+  #endif
   refresh_callback_ = std::move(callback);
   Refresh(refresh_thumbnails);
 }
diff --git a/chrome/browser/media/webrtc/native_desktop_media_list.cc b/chrome/browser/media/webrtc/native_desktop_media_list.cc
index 0ac8e20073bd2db507e49200fd0b48f8535d666b..dd82cd565c5cb61d5d530d3d67bbbb384772466e 100644
--- a/chrome/browser/media/webrtc/native_desktop_media_list.cc
+++ b/chrome/browser/media/webrtc/native_desktop_media_list.cc
@@ -46,6 +46,7 @@
 #endif
 
 #if BUILDFLAG(IS_MAC)
+#include "chrome/browser/media/webrtc/thumbnail_capturer_mac.h"
 #include "components/remote_cocoa/browser/scoped_cg_window_id.h"
 #endif
 
@@ -181,14 +182,16 @@ BASE_FEATURE(kWindowCaptureMacV2,
 
 content::DesktopMediaID::Type ConvertToDesktopMediaIDType(
     DesktopMediaList::Type type) {
+  // LOG(INFO) << "Inside ConvertToDesktopMediaIDType";
   switch (type) {
     case DesktopMediaList::Type::kScreen:
       return content::DesktopMediaID::Type::TYPE_SCREEN;
     case DesktopMediaList::Type::kWindow:
       return content::DesktopMediaID::Type::TYPE_WINDOW;
+    case DesktopMediaList::Type::kNone:
+      // return content::DesktopMediaID::Type::TYPE_NONE;
     case DesktopMediaList::Type::kWebContents:
     case DesktopMediaList::Type::kCurrentTab:
-    case DesktopMediaList::Type::kNone:
       break;
   }
   NOTREACHED();
@@ -532,7 +535,10 @@ NativeDesktopMediaList::Worker::FormatSources(
   std::vector<SourceDescription> source_descriptions;
   std::u16string title;
   for (size_t i = 0; i < sources.size(); ++i) {
+    // LOG(INFO) << "source_type" << source_type;
     switch (source_type) {
+      // case DesktopMediaID::Type::TYPE_NONE:
+        // continue;
       case DesktopMediaID::Type::TYPE_SCREEN:
         // Just in case 'Screen' is inflected depending on the screen number,
         // use plural formatter.
@@ -545,11 +551,23 @@ NativeDesktopMediaList::Worker::FormatSources(
         break;
 
       case DesktopMediaID::Type::TYPE_WINDOW:
+      #if BUILDFLAG(IS_MAC)
+              // If using NativeScreenCapturePickerMac,
+              // skipping the picker will skip the first window selection.
+              if (ShouldUseSCContentSharingPicker()) {
+                title = base::UTF8ToUTF16(sources[i].title);
+              } else if (sources[i].id == excluded_window_id) {
+              // Skip the picker dialog window.
+                continue;
+              }
+              title = base::UTF8ToUTF16(sources[i].title);
+      #else
         // Skip the picker dialog window.
         if (sources[i].id == excluded_window_id) {
           continue;
         }
         title = base::UTF8ToUTF16(sources[i].title);
+      #endif
         break;
 
       default:
diff --git a/chrome/browser/media/webrtc/thumbnail_capturer_mac.h b/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
index 12a74f8f32cc00a7f3d7802865ae4b309961341d..acbcfb08ae8c44e24a04b326096289428bc6ff60 100644
--- a/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
+++ b/chrome/browser/media/webrtc/thumbnail_capturer_mac.h
@@ -8,6 +8,9 @@
 #include "chrome/browser/media/webrtc/desktop_media_list.h"
 #include "chrome/browser/media/webrtc/thumbnail_capturer.h"
 
+// Returns true if the SCK sharing picker is available and enabled.
+bool ShouldUseSCContentSharingPicker();
+
 // Returns true if the SCK thumbnail capturer is available and enabled.
 bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type);
 
diff --git a/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm b/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
index 47a5ad2b7e2bc86a614488fd3fe85da1e3e2d6f2..7f11a73e8a109c3bdf689d510850e82902305e6e 100644
--- a/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
+++ b/chrome/browser/media/webrtc/thumbnail_capturer_mac.mm
@@ -761,6 +761,8 @@ void OnCapturedFrame(base::apple::ScopedCFTypeRef<CGImageRef> image,
                                       source_id);
 }
 
+}  // namespace
+
 bool ShouldUseSCContentSharingPicker() {
   if (@available(macOS 15.0, *)) {
     if (base::FeatureList::IsEnabled(media::kUseSCContentSharingPicker)) {
@@ -770,8 +772,6 @@ bool ShouldUseSCContentSharingPicker() {
   return false;
 }
 
-}  // namespace
-
 bool ShouldUseThumbnailCapturerMac(DesktopMediaList::Type type) {
   // There was a bug in ScreenCaptureKit that was fixed in 14.4,
   // see b/40076027.
diff --git a/content/browser/media/capture/native_screen_capture_picker_mac.mm b/content/browser/media/capture/native_screen_capture_picker_mac.mm
index f3dbdd0db5f6c3d07b600f3dfa3267d0a5a57b81..c61e1c9d4a67bc52deb69429abf2dc4bf9a79556 100644
--- a/content/browser/media/capture/native_screen_capture_picker_mac.mm
+++ b/content/browser/media/capture/native_screen_capture_picker_mac.mm
@@ -99,6 +99,7 @@ void Open(DesktopMediaID::Type type,
             base::OnceCallback<void(Source)> picker_callback,
             base::OnceClosure cancel_callback,
             base::OnceClosure error_callback) override;
+            // boolean use_system_picker) override;
   void Close(DesktopMediaID device_id) override;
   std::unique_ptr<media::VideoCaptureDevice> CreateDevice(
       const DesktopMediaID& source) override;
@@ -138,8 +139,11 @@ void Open(DesktopMediaID::Type type,
     base::OnceClosure cancel_callback,
     base::OnceClosure error_callback) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  CHECK(type == DesktopMediaID::Type::TYPE_SCREEN ||
-        type == DesktopMediaID::Type::TYPE_WINDOW);
+  // Chrome doesn't allow both screens & windows in their picker,
+  // but Electron does - add a check for TYPE_NONE.
+  // CHECK(type == DesktopMediaID::Type::TYPE_SCREEN ||
+  //       type == DesktopMediaID::Type::TYPE_WINDOW ||
+  //       type == DesktopMediaID::Type::TYPE_NONE);
   if (@available(macOS 14.0, *)) {
     NSNumber* source_id = @(next_id_);
     auto picker_observer = [[PickerObserver alloc]
@@ -157,19 +161,26 @@ void Open(DesktopMediaID::Type type,
     // TODO(https://crbug.com/360781940): Add support for changing selected
     // content. The problem to solve is how this should interact with stream
     // restart.
-    config.allowsChangingSelectedContent = false;
+    config.allowsChangingSelectedContent = true;
     NSNumber* max_stream_count = @(kMaxContentShareCountValue.Get());
-    if (type == DesktopMediaID::Type::TYPE_SCREEN) {
-      config.allowedPickerModes = SCContentSharingPickerModeSingleDisplay;
-      picker.defaultConfiguration = config;
-      picker.maximumStreamCount = max_stream_count;
-      [picker presentPickerUsingContentStyle:SCShareableContentStyleDisplay];
-    } else {
-      config.allowedPickerModes = SCContentSharingPickerModeSingleWindow;
-      picker.defaultConfiguration = config;
-      picker.maximumStreamCount = max_stream_count;
-      [picker presentPickerUsingContentStyle:SCShareableContentStyleWindow];
-    }
+    // LOG(ERROR) << "Type: " << type;
+    // Chrome doesn't allow both screens & windows in their picker,
+    // but Electron does; we patch out the MediaID::Type conditional here
+    // if (type == DesktopMediaID::Type::TYPE_SCREEN) {
+    //   config.allowedPickerModes = SCContentSharingPickerModeSingleDisplay;
+    //   picker.defaultConfiguration = config;
+    //   picker.maximumStreamCount = max_stream_count;
+    //   [picker presentPickerUsingContentStyle:SCShareableContentStyleDisplay];
+    // } else if (type == DesktopMediaID::Type::TYPE_WINDOW) {
+    //   config.allowedPickerModes = SCContentSharingPickerModeSingleWindow;
+    //   picker.defaultConfiguration = config;
+    //   picker.maximumStreamCount = max_stream_count;
+    //   [picker presentPickerUsingContentStyle:SCShareableContentStyleWindow];
+    // } else {
+    picker.defaultConfiguration = config;
+    picker.maximumStreamCount = max_stream_count;
+    [picker present];
+    // }
   } else {
     NOTREACHED();
   }
